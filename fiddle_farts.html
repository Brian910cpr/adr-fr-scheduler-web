Line wrap
<script>
(() => {
const API_BASE = "https://adr-fr-scheduler-api.brian-9ac.workers.dev";
const cycle = ["prefer","available","unset","no"];
const label = { prefer:"Prefer", available:"Available", unset:"Unset", no:"Do Not" };

// SELECTORS — adjust to your actual markup classes if needed
const SELECTORS = {
dayCard: ".day", // container per date, has data-date
intentBtn: ".intent-btn", // the colored pill the user taps
noteInput: ".note-input" // small text input next to AM/PM
};

// Fetch helpers with friendly CORS errors
async function apiGET(path) {
const r = await fetch(API_BASE + path, { credentials: "omit" });
if (!r.ok) throw new Error(`GET ${path} -> ${r.status}`);
return r.json();
}
async function apiPOST(path, data) {
const r = await fetch(API_BASE + path, {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(data)
});
if (!r.ok) {
const t = await r.text().catch(()=> "");
throw new Error(`POST ${path} -> ${r.status} ${t}`);
}
return r.json();
}

// Apply visual state on a button without changing CSS structure
function setBtnState(btn, state) {
btn.dataset.state = state;
btn.textContent = label[state] || "Unset";
// If you have state classes, toggle here; otherwise text-only is fine.
btn.classList.remove("prefer","available","unset","no");
btn.classList.add(state);
}

// Toggle algorithm: Prefer → Available → Unset → Do Not → Prefer
function nextState(cur) {
const i = cycle.indexOf(cur);
return cycle[(i + 1) % cycle.length];
}

// Debounce for notes
function debounce(fn, ms=400) {
let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
}

// Wire one intent button
function wireIntentButton(btn) {
btn.addEventListener("click", async () => {
const userId = btn.dataset.user;
const date = btn.dataset.date;
const half = btn.dataset.half; // AM/PM
const cur = btn.dataset.state || "unset";
const next = nextState(cur);

// find sibling note input (optional)
const day = btn.closest(SELECTORS.dayCard);
let noteVal = "";
if (day) {
const n = day.querySelector(`${SELECTORS.noteInput}[data-half="${half}"]`);
if (n) noteVal = n.value || "";
}

// optimistic
setBtnState(btn, next);

try {
await apiPOST("/api/availability", { userId, date, half, state: next, note: noteVal });
// optionally flash a tiny "saved" tag; keeping UI unchanged otherwise
} catch (e) {
// rollback on error
setBtnState(btn, cur);
console.error("save intent failed:", e);
alert("Network error saving your selection. If this keeps happening, it’s likely CORS/SSL. (We just patched CORS in the Worker.)");
}
});
}

// Wire one note input
function wireNoteInput(input) {
const save = debounce(async () => {
const userId = input.dataset.user;
const date = input.dataset.date;
const half = input.dataset.half;
// current state from the neighbor button (don’t change it)
const btn = input.closest(SELECTORS.dayCard)?.querySelector(`${SELECTORS.intentBtn}[data-half="${half}"]`);
const cur = btn?.dataset.state || "unset";

try {
await apiPOST("/api/availability", { userId, date, half, state: cur, note: input.value || "" });
} catch (e) {
console.error("save note failed:", e);
// Don’t change visuals; user can try again
}
}, 450);

input.addEventListener("input", save);
input.addEventListener("keydown", (ev) => {
if (ev.key === "Enter") { ev.preventDefault(); save(); }
});
}

// Initial paint wiring — no visual/markup changes
function bootWire() {
document.querySelectorAll(SELECTORS.intentBtn).forEach((btn) => {
// default state if missing
if (!btn.dataset.state) setBtnState(btn, "unset");
wireIntentButton(btn);
});
document.querySelectorAll(SELECTORS.noteInput).forEach(wireNoteInput);
}

// Optional: tiny bulk tools restore (no CSS changes)
function wireBulkTools() {
const bulk = document.getElementById("bulk-apply");
if (!bulk) return;
bulk.addEventListener("click", async () => {
// expects you have hidden inputs/selects with IDs below; this does not change UI
const userId = document.getElementById("bulk-user")?.value;
const start = document.getElementById("bulk-start")?.value;
const end = document.getElementById("bulk-end")?.value;
const am = document.getElementById("bulk-am")?.value; // '', prefer, available, unset, no
const pm = document.getElementById("bulk-pm")?.value;
if (!userId || !start || !end) return alert("Need user/start/end");

// build date range
const dates = [];
let d = new Date(start + "T12:00:00Z");
const to = new Date(end + "T12:00:00Z");
while (d <= to) { dates.push(d.toISOString().slice(0,10)); d.setUTCDate(d.getUTCDate()+1); }

// throttle in chunks to avoid hammering
const jobs = [];
for (const date of dates) {
if (am) jobs.push(apiPOST("/api/availability", { userId, date, half:"AM", state: am }));
if (pm) jobs.push(apiPOST("/api/availability", { userId, date, half:"PM", state: pm }));
}
for (let i=0;i<jobs.length;i+=12) { await Promise.all(jobs.slice(i,i+12)); }
alert("Bulk applied.");
// you can optionally re-fetch and repaint
});
}

// Kick
bootWire();
wireBulkTools();
})();
</script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"bc555786f29c4ef2890c5089797a3b0c","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
